import h5py
import torch
import numpy as np
import os
from tqdm import tqdm
import pathlib

# -----------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------
# Get TACC Scratch directory
scratch_dir = os.environ['SCRATCH']

# Path to the HDF5 file generated by the Julia script
data_path = os.path.join(scratch_dir, 'nips_prelim', 'nips_9d_data_gen.h5')

# Output path for the curated PyTorch file
output_dir = os.path.join(scratch_dir, 'simulation_data', 'surrogate_training')
os.makedirs(output_dir, exist_ok=True)
fname = os.path.join(output_dir, f"{pathlib.Path(data_path).stem}_curated.pt")

# -----------------------------------------------------------
# PROCESSING
# -----------------------------------------------------------
print(f"Loading data from: {data_path}")

with h5py.File(data_path, 'r') as f:
    energies = torch.from_numpy(f["energies"][:]).float() # shape (Nw,)
    
    # Get list of sample keys
    all_keys = list(f.keys())
    valid_samples = [k for k in all_keys if 'sample_' in k]
    n_samples = len(valid_samples)
    print(f"Found {n_samples} samples.")

    # Get shapes from the first sample to fix dimension ordering
    first_sample = f[valid_samples[0]]
    
    # Python reads Julia's (2500, 3) as (3, 2500) due to column-major storage
    q_sample_raw = first_sample["qs_rlu"][:] 
    
    # Python reads Julia's (150, 2500) as (2500, 150)
    data_sample_raw = first_sample["data"][:] 
    
    # CORRECT THE DIMENSIONS
    if q_sample_raw.shape[0] == 3:
        print("Detected transposed Coordinates (3, Nq). Transposing to (Nq, 3)...")
        nq = q_sample_raw.shape[1]
    else:
        nq = q_sample_raw.shape[0]
        
    # For data, we want (Nq, Nw)
    # If raw is (2500, 150), that matches (Nq, Nw)
    nw = data_sample_raw.shape[1]
    
    print(f"Corrected Dimensions: Nq={nq}, Nw={nw}")

    # --- MEMORY OPTIMIZATION START ---
    print("Pre-allocating tensors to save memory...")
    
    # Q: (Ns, Nq, 3)
    q_tensor = torch.zeros((n_samples, nq, 3), dtype=torch.float32)
    
    # SQW: (Ns, Nq, Nw)
    sqw_tensor = torch.zeros((n_samples, nq, nw), dtype=torch.float32)
    
    # Params: (Ns, 9)
    param_order = ['Ax', 'Az', 'J1a', 'J1b', 'J2a', 'J2b', 'J3a', 'J3b', 'J4']
    print(f"Parameter tensor order: {param_order}")
    params_tensor = torch.zeros((n_samples, 9), dtype=torch.float32)
    
    # Keep legacy list of dicts
    p_dset = []

    print("Processing samples into pre-allocated tensors...")
    
    for i, key in tqdm(enumerate(valid_samples), total=n_samples, desc='Curating'):
        sample_data = f[key]
        
        # 1. Coordinates
        # Read (3, 2500) -> Transpose to (2500, 3)
        q_val = sample_data["qs_rlu"][:]
        if q_val.shape[0] == 3:
            q_val = q_val.T
        q_tensor[i] = torch.from_numpy(q_val)
        
        # 2. Intensity
        # Read (2500, 150). This is already (Nq, Nw), so we DO NOT transpose.
        d_val = sample_data["data"][:]
        sqw_tensor[i] = torch.from_numpy(d_val)
        
        # 3. Parameters
        params_dict = {k: float(v[()]) for k, v in sample_data["params"].items()}
        p_dset.append(params_dict)
        
        # Vectorize parameters
        p_vec = [params_dict[k] for k in param_order]
        params_tensor[i] = torch.tensor(p_vec, dtype=torch.float32)

# -----------------------------------------------------------
# SAVE
# -----------------------------------------------------------
print("Creating dictionary...")
dataset = {
    'w': energies,
    'q': q_tensor,
    'sqw': sqw_tensor,
    'params': p_dset,
    'params_tensor': params_tensor,
    'params_order': param_order 
}

print(f"Saving to {fname}...")
print(f"Final Shapes:")
print(f"  Q: {dataset['q'].shape}")
print(f"  S(q,w): {dataset['sqw'].shape}")
print(f"  Params: {dataset['params_tensor'].shape}")

# Save
torch.save(dataset, fname)
print("Done.")
